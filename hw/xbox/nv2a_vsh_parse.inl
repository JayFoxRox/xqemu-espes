/* GLSL */

"\n"
"/* Generic RTZ for normalized 'n' bit signed */\n"
"IFloat normalizeUintN(uint n, uint v) {\n"
"    uint max = (1U << n) - 1U;\n"
"    if (v == 0U) { return 0x00000000U; }\n"
"    if (v >= max) { return 0x3F800000U; }\n"
"    uint base = 0x3F800000U - (n << 23U);\n"
"    uint value = v << (n - 1U);\n"
"    while(value > max) {\n"
"      value >>= 1U;\n"
"      base += 0x800000U;\n"
"    }\n"
"    uint pattern = 1U;\n"
"    uint shift = n;\n"
"    while(shift < 23U) {\n"
"      pattern <<= n;\n"
"      pattern |= 1U;\n"
"      shift += n;\n"
"    }\n"
"    return base | ((value * pattern >> shift % 24U) & 0x7FFFFFU);\n"
"}\n"
"\n"
"/* Generic RTZ for normalized 'n' bit signed */\n"
"IFloat normalizeIntN(uint n, int v) {\n"
"    IFloat i;\n"
"    if (v < 0) {\n"
"      i = 0x80000000U;\n"
"      v = -v - 1;\n"
"    } else {\n"
"      i = 0U;\n"
"    }\n"
"    return i | normalizeUintN(n, (uint(v) << 1U) | 1U);\n"
"}\n"
"\n"
"IFloat4 parseNormalizedUint8RGBA(uvec4 v) {\n"
"  return IFloat4(normalizeUintN(8U, v.r),\n"
"                 normalizeUintN(8U, v.g),\n"
"                 normalizeUintN(8U, v.b),\n"
"                 normalizeUintN(8U, v.a));\n"
"}\n"
"\n"
"IFloat4 parseNormalizedUint8BGRA(uvec4 v) {\n"
"  return parseNormalizedUint8RGBA(v.bgra);\n"
"}\n"
"\n"
"IFloat4 parseInt16(ivec4 v) {\n"
"  return Vec4ToIFloat4(vec4(v));\n"
"}\n"
"\n"
"IFloat4 parseNormalizedInt16(ivec4 v) {\n"
"  return IFloat4(normalizeIntN(16U, v.x),\n"
"                 normalizeIntN(16U, v.y),\n"
"                 normalizeIntN(16U, v.z),\n"
"                 normalizeIntN(16U, v.w));\n"
"}\n"
"\n"
"IFloat4 parseCompressed(uint v) {\n"
"  return IFloat4(normalizeIntN(11U, int((v & 0x7FFU) << 21U) >> 21),\n"
"                 normalizeIntN(11U, int((v & 0x3FF800U) << 10U) >> 21),\n"
"                 normalizeIntN(10U, int(v & 0xFFC00000U) >> 22),\n"
"                 IFloatOne);\n"
"}\n"
"\n"
"IFloat4 parseFloat32(uvec4 v) {\n"
"  return v;\n"
"}\n"
