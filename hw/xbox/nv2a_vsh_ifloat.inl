/* GLSL */

"\n"
"#define IFloat uint\n"
"#define IFloat2 uvec2\n"
"#define IFloat3 uvec3\n"
"#define IFloat4 uvec4\n"
"\n"
"const IFloat IFloatZero = 0x00000000U;\n"
"const IFloat IFloatOne = 0x3F800000U;\n"
"const IFloat IFloatInf = 0x7F800000U;\n"
"const IFloat IFloatNaN = 0x7FFFFFFFU;\n"
"\n"
"IFloat FloatToIFloat(float x) { return floatBitsToUint(x); }\n"
"IFloat4 Vec4ToIFloat4(vec4 x) { return floatBitsToUint(x); }\n"
"float IFloatToFloat(IFloat x) { return uintBitsToFloat(x); }\n"
"vec4 IFloat4ToVec4(IFloat4 x) { return uintBitsToFloat(x); }\n"
"\n"
"bool IFloatIsZero(IFloat x) {\n"
"  return (x & 0x7FFFFFFFU) == 0U;\n"
"}\n"
"\n"
"bool IFloatIsNaN(IFloat x) {\n"
"  return ((x & 0x7F800000U) == 0x7F800000U) && ((x & 0x7FFFFFU) != 0U);\n"
"}\n"
"\n"
"bool IFloatIsInf(IFloat x) {\n"
"  return (x & 0x7FFFFFFFU) == 0x7F800000U;\n"
"}\n"
"\n"
"IFloat IFloatNegate(IFloat x) {\n"
"  return x ^ 0x80000000U;\n"
"}\n"
"\n"
"IFloat4 IFloat4Negate(IFloat4 x) {\n"
"  return IFloat4(IFloatNegate(x.x),\n"
"                 IFloatNegate(x.y),\n"
"                 IFloatNegate(x.z),\n"
"                 IFloatNegate(x.w));\n"
"}\n"
"\n"
"IFloat IFloatMultiply(IFloat a, IFloat b) {\n"
/* FIXME: Precision.. */
"  return FloatToIFloat(IFloatToFloat(a) * IFloatToFloat(b));\n"
"}\n"
"\n"
"IFloat4 IFloat4Multiply(IFloat4 a, IFloat4 b) {\n"
"  return IFloat4(IFloatMultiply(a.x, b.x),\n"
"                 IFloatMultiply(a.y, b.y),\n"
"                 IFloatMultiply(a.z, b.z),\n"
"                 IFloatMultiply(a.w, b.w));\n"
"}\n"
"\n"
"IFloat IFloatAdd(IFloat a, IFloat b) {\n"
/* FIXME: Precision.. */
"  return FloatToIFloat(IFloatToFloat(a) + IFloatToFloat(b));\n"
"}\n"
"\n"
"IFloat4 IFloat4Add(IFloat4 a, IFloat4 b) {\n"
"  return IFloat4(IFloatAdd(a.x, b.x),\n"
"                 IFloatAdd(a.y, b.y),\n"
"                 IFloatAdd(a.z, b.z),\n"
"                 IFloatAdd(a.w, b.w));\n"
"}\n"
